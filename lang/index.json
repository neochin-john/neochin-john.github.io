[{"content":"概述 本文列出了倒位序重排的原始问题，数列的规律和性质，以及暴力解法、kaldi中的迭代解法、倒位序重排三种解法，并给出了理论证明。最后对问题做了部分延伸。\n求解问题 先忽略“倒位序重排”这一串名词，看一个问题。用一张图直观描述一个序列长度为16的操作过程。图片来自Radix 2 FFT。\n根据图示描述，对于输入序列，按偶数位置的数依次放左边，奇数位置的数依次放右边的方式，不断二分。下文简单描述为奇偶二分。\n现在问题来了：有一个2的n次幂的序列，按这样的奇偶二分操作后，如何求最终得到的序列？\n因为求解过程只与元素所在的位置相关，为了方便操作，我们将这个序列看成是从0到n-1的一串有序数列。因为一旦求得这个结果序列，即找到了元素应该放置的新位置。\n悄悄给你们透点风，我在入门快速傅立叶变换FFT，它需要这个东西。\n暴力解法 一切还是从简单的方法入手，先写个基础程序暴力求解，除了帮助理解问题以外，还可以作为验证程序。\n先就不动脑子了，让双手操作起来。不就是偶数左边放，奇数右边放吗，如此二分下去，直到不可分。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import sys def split_even_odd(seq): if len(seq) \u0026lt;= 2: return seq # 以步长为2做切片 even = seq[::2] odd = seq[1::2] even = split_even_odd(even) odd = split_even_odd(odd) return even + odd if __name__ == \u0026#39;__main__\u0026#39;: log2N = int(sys.argv[1]) seq = list(range(1\u0026lt;\u0026lt;log2N)) print(seq, sep=\u0026#39;,\u0026#39;) new_seq = split_even_odd(seq) print(new_seq, sep=\u0026#39;,\u0026#39;) 查看输出结果：\n[leo@leo-m rev]$ python rev.py 1 [0, 1] [0, 1] [leo@leo-m rev]$ python rev.py 2 [0, 1, 2, 3] [0, 2, 1, 3] [leo@leo-m rev]$ python rev.py 3 [0, 1, 2, 3, 4, 5, 6, 7] [0, 4, 2, 6, 1, 5, 3, 7] [leo@leo-m rev]$ python rev.py 4 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]\n当有 $N$ 个数, 且 $N$ 很大时，在树形结构中可以看出分 $log_2^N$ 层，每一层都会遍历所有数，时间复杂度为 $O(N*logN)$。\n而且这个程序太简单，有一些缺点：\n其中操作数组切片，伴随内存申请和拷贝，影响效率。 使用递归，在大 $N$ 的序列下，可能导致栈溢出。 这些从技术上是可以优化的，但是我不想折腾了，因为已经达到验证程序的目的。\nkaldi中的迭代解法 代码印象 kaldi是语音识别方面的开源实现工具或者说是框架。kaldi中改进解法\n1 2 3 4 5 6 7 8 9 10 brseed_ = new MatrixIndexT[1 \u0026lt;\u0026lt; lg2]; brseed_[0] = 0; brseed_[1] = 1; for (j = 2; j \u0026lt;= lg2; j++) { imax = 1 \u0026lt;\u0026lt; (j - 1); for (i = 0; i \u0026lt; imax; i++) { brseed_[i] \u0026lt;\u0026lt;= 1; brseed_[i + imax] = brseed_[i] + 1; } } 用草稿大概推算一下，第一个for循环log2N步，相当于二分的树形结构的层数。然后每层在上一层的基础上*2加上*2 + 1就可得出。而基础层是[0, 1]两个数，第二层就是[0, 2, 1, 3]，第三层就是[0, 4, 2, 6, 1, 5, 3, 7]，以此类推。\n是不是看到了上面暴力解法的结果了？这么神奇的吗？这些数还有这种规律？\n这个算法循环log2N次，每次循环中大约再循环(第二个for)2, 4, 8,...,N，算下来时间复杂度为 $O(N)$。并且只有移位和加法，没有频繁的内存申请拷贝等，非常高效。\n其它一些神奇的规律 隐藏的序列 序列长 $log_2^N$ 结果 2 1 [0, 1] 4 2 [0, 2, 1, 3] 8 3 [0, 4, 2, 6, 1, 5, 3, 7] 16 4 [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15] 除了上面的kaldi层*2和*2 + 1的规律外，还能发现各项数据中都有[0, 2, 1, 3]这段序列的影子。\n比如长度为8的结果，[0, 4, 2, 6]其实是[0, 2, 1, 3] * 2。而全结果为[[0, 4] + 0, [0, 4] + 2, [0, 4] + 1, [0, 4] + 3]。 比如长度为16的结果，[0, 8, 4, 12]其实是[0, 2, 1, 3] * 4。而[0, 8, 4, 12, 2, 10, 6, 14]又是[[0, 8] + 0, [0, 8] + 2*2, [0, 8] + 2*1, [0, 8] + 2*3]。其它数据也有类似结果。 固定的位置规律 # 长度4 [0, 1, 2, 3] [0, 2, 1, 3] # 长度8 [0, 1, 2, 3, 4, 5, 6, 7] [0, 4, 2, 6, 1, 5, 3, 7] # 长度16 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15] 通过上面的序列可以发现:\n首尾两个数变换前后没有任何移动。看长度为4时的0和3，长度为8时的0和7，等等。 第二个位置上的数，会移到中位数后面，比如长度为16时的1。 倒数第二个位置上的数，会移到中位数前面，比如长度为16时的14。 中位数后面的那个数，会移到第二个位置，比如长度为16时的8。 中位数前面的那个数，会移到倒数第二个位置，比如长度为16时的7。 中位数前或者后的第二个数，位置不变，比如长度为16时的6，9。 等等等等规律，让这个序列看起来很神奇。\n用数学解释kaldi的迭代方法 暴力解法中，我们的视角是从序列的操作出发。而从数据上看，是能发现很多规律的。而kaldi中的方法就是从数据的数学关系角度出发的。\nkaldi的 代码 使用的是一种迭代办法，某一层的结果是对上一层结果的变换。所以要证明的是迭代关系。\n首先我们使用长度位8的数做例子，写起来方便。\n令$x = (0, 1, \u0026hellip;, 7)$。\n第一次奇偶二分后，得到:\n$$\n\\left \\{\n\\begin{array}{ll}\nx_{even} \u0026amp; = (0, 2, 4, 6) \\\\\nx_{odd} \u0026amp; = (1, 3, 5, 7) \\\\\nx_{odd} \u0026amp; = x_{even} + 1\n\\end{array}\n\\right.\n$$\n令$x\u0026rsquo; = (0, 1, 2, 3)$，可得：\n$$ x_{even} = x\u0026rsquo; * 2 $$\n再对$x_{even}$ 做后续的奇偶二分，相当于对 $x\u0026rsquo;$做奇偶二分的基础上再$*2$。\n由此递归进行，最终得到基础的一层序列$(0, 1)$。\n综上所述，可得到：\n$$\n\\left \\{\n\\begin{array}{ll}\nx_{n, left} \u0026amp; = x_{n-1} * 2 \\\\\nx_{n, right} \u0026amp; = x_{n, left} + 1 = x_{n-1} * 2 + 1 \\\\\nx_{n} \u0026amp; = (x_{n, left}, x_{n, right}) \\\\\nx_0 \u0026amp; = (0, 1) \\\\\nn \u0026amp; = (0, 1, \u0026hellip;, log_2^N - 1)，其中N为序列长度\n\\end{array}\n\\right.\n$$\n倒位序重排 半篇文章已完，是不是已经忘记了“倒位序重排”几个字了?\n倒位序是什么？跟前文解决的问题有什么关系？\n一开始我以为“倒位序重排”就是“颠倒位置重新排序”，但看到英文名“Bit Reversal Permutation”之后才知道，这个位不是指“位置”，而是值“bit位”。\n其实，前文的算法是求解倒位序重排的几种方法，只是没有利用“倒位”特点。\n什么，还有特点？\n是的，你没看错，这个序列太神奇了。下面介绍从二进制的表示上看，还有一个神奇的规律。\n倒位 “位”是计算机表示信息的最小单位。\n看一些倒位数例子，为方便查看，使用-代替0：\n数 二进制 倒位数 倒位数二进制 1 -------1 128 1------- 2 ------1- 64 -1------ 5 -----1-1 160 1-1----- 通过例子可以看出，倒位数顾名思义，是将原数按二进制表示，倒过来写，最后求得的数。\n是不是想到了计算机中大端小端的概念了？通常计算机中提到的大端小端的时候，都是Byte与Byte之间的顺序关系，而不是bit与bit的位序关系，因为CPU以Byte为单位来处理，所以关注的焦点不一样。不过我也有一个未求证的理解，计算机的大端小端也描述了位序的排列方式。\n倒位序 倒位序，首先描述的对象为一个序列。简单的说，对于一个数列中的每一个数，按所在的位置的倒位数重新放置，最终得到新的序列。\n举个例子，有8个数，从0-7。原序列为：\n原序列 - - - - - - - - 原序列 0 1 2 3 4 5 6 7 二进制 000 001 010 011 100 101 110 111 倒位序 - - - - - - - - 倒位序 0 4 2 6 1 5 3 7 二进制 000 100 010 110 001 101 011 111 可自己试试不同长度的序列，并细致的看倒位序的二进制关系，不难发现：\n每个位置上，按序列的可表示位数 $log_2^N$ 求数的倒位数，得出的序列即为倒位数序列。 倒位数序列是倒位序的，可以看作“由小到大，向右进位的数列”。 得到这个特性，惊不惊喜，意不意外？\n反正我是惊呆了，将序列不断的奇偶二分，居然得到了右进位的序列，并且每个得到的位置上的数是原数的倒位数。\n这个特性的怎么证明呢？在网上一顿搜索“倒位序重排”，结果全是结论和代码，很难知道结论是如何得出的。也许有很多资料说明了，但我不知道用什么关键字搜到它。\n证明奇偶二分得到倒位序 因为没搜到过多的资料，下面纯粹是个人的证明方式。谨慎观之。\n简单证明办法 按照奇偶二分操作步骤来描述：\n第一次奇偶二分，把数列分成了两部分。其中最低位为0的放左边，为1放右边。写作[***0 ... ***1] 第二次奇偶二分，在第一步的基础上二分。其中倒数第2位为0的放左边，为1放右边。写作[**00 **10 ... **01 **11] 第三次奇偶二分，在第二步的基础上二分。其中倒数第3位为0的放左边，为1放右边。写作[*000 *100 *010 *110 ... *001 *101 *011 *111] \u0026hellip; 得出：\n从右向左看二进制，将0放左边，将1放右边。最后就会得到一串从左向右进位的有序二进制序列。 原序列从右到左进位，结果序列从左到右进位。两个序列上的数只是进位表示不同，互为倒位数。 这种证明好像已经可以了，但又像是直觉层面上的证明。所以下面又尝试了复杂一点的证明办法。\n倒位数性质 为了方便后续的证明理解，容我嚣张地定义一下倒位数与原数的一些性质。\n令:\nBR(x,log2N)为倒位方法（“BR”是“Bit Reverse”的缩写，x是被求数，log2N可解释为序列位置可以用log2N个bit表示）。举个例子：如果按4位表示所有的数，则BR(1, 4) = BR(0001b, 4) = 1000b = 8。如果按3位表示所有的数，则BR(1, 3) = BR(001b, 3) = 100b = 4。\n为什么要假设按4位表示、或者按3位表示所有的数？前面的“倒位序”章节可以看到倒位序重排与数的大小（其实是序列长度）有关，不同的序列长度，求的倒位数不同。 BR(x, log2N)中的x可以为序列，表示的意思是对序列中的每个元素分别求倒位数，即BR([x_1, x_2, ..., x_n], log2N) = [BR(x_1, log2N), BR(x_2, log2N), ..., BR(x_n, log2N)]。 越简单的东西越难证明，但就像1+1=2一样，这么的天经地义：\nx = BR(BR(x, log2N), log2N)，使用相同位数表示的情况下，一个数的倒位数的倒位数就是它本身。 BR(2^log2N, log2N + 1) = 1，举例：3位表示的1b，倒位数位100b，而100b的倒位数位1b。 BR(x \u0026lt;\u0026lt; 1, log2N + 1) = BR(x, log2N + 1) \u0026gt;\u0026gt; 1，一个数左移一位的倒位数，相当于它的倒位数右移一位。这里也要特别说明，数可能会溢出。比如3位表示的5，二进制位101b，当它左移时会溢出，只能用4位表示了：101b\u0026lt;\u0026lt;1 = 1010b。所以，log2N + 1是为了满足溢出的情况。 BR((x \u0026lt;\u0026lt; 1) + 1, log2N + 1) = (BR(x, log2N + 1) \u0026gt;\u0026gt; 1) + BR(1, log2N + 1)，一个数左移一位再加1的倒位数，相当于它的倒位数右移一位加上1的倒位数。log2N + 1的解释同上，也是为了满足数溢出的情况。这个用例子解释，4bit表示的3： 1 2 3 4 5 6 7 8 9 10 BR((3 \u0026lt;\u0026lt; 1) + 1, 3 + 1) = BR((0011b \u0026lt;\u0026lt; 1) + 1, 4) = BR(0110b + 1, 4) = BR(0111b, 4) = 1110b = 0110b + 1000b = (1100b \u0026gt;\u0026gt; 1) + 1000b = (BR(BR(1100b, 4), 4) \u0026gt;\u0026gt; 1) + BR(BR(1000b, 4), 4) = (BR(0011b, 4) \u0026gt;\u0026gt; 1) + BR(0001b, 4) = (BR(3, 3 + 1) \u0026gt;\u0026gt; 1) + BR(1, 3 + 1) BR(x, log2N) = BR(x, log2N + 1) \u0026gt;\u0026gt; 1，这个用例子解释，4bit表示的3： 1 2 3 4 5 6 7 BR(3, 4) = BR(0011b, 4) = 1100b = 11000b \u0026gt;\u0026gt; 1 = BR(BR(11000b, 5), 5) \u0026gt;\u0026gt; 1 = BR(00011b, 5) \u0026gt;\u0026gt; 1 = BR(3, 4 + 1) \u0026gt;\u0026gt; 1 BR(x + 2^log2N, log2N + 1) = BR(x, log2N + 1) + BR(2^log2N, log2N + 1) = BR(x, log2N + 1) + 1，log2N bit表示的一个二进制数，加上一个2 ^ log2N的数，相当于使用(log2N + 1) bit表示这个数，并置最高位为1。所以它的倒位数也相当于扩展了一个表示位后，再加1。例子说明： 1 2 3 4 5 6 7 8 BR(2 + 2 ^ 2, 2 + 1) = BR(010b + 100b, 3) = BR(110b, 3) = 011b = 010b + 001b = BR(BR(010b, 3), 3) + 001b = BR(010b, 3) + 1 = BR(2, 2 + 1) + 1 演绎证明 要证明奇偶二分后的序列是倒位序需要证明2点：\n每个位置上，按序列的可表示位数 $log_2^N$ 求数的倒位数，得出的序列即为倒位数序列。 倒位数序列是倒位序的，可以看作“由小到大，向右进位的数列”。 其中第2点不需要多证明，因为如果证明了第1点，对于一个有序序列的二进制表示中，由从右向左进位的数表示，经过每个数倒位后，就变成从左向右进位。如果有点绕，可以想象一下，分别用“大端”和“小端”按位储存这个数据。\n所以主要证明第1点，等价证明奇偶二分后每个位置上的数等于原位置的倒位数。\n从前面用数学解释kaldi的迭代方法中可得到倒位序迭代关系。结合倒位数性质，我们只要证明最开始的迭代过程满足倒位序条件，就可以推广到无穷的情况。\n为了方便数值的表示，我们先约定：\n$i_n$ 表示长度为 $N$ 的原数列，其中$n = log_2^N - 1$。也等于倒位序的位置索引序列，固定为[0, 1, 2, ..., N - 1]。 $i_{n, left}$表示 $i_n$ 的左半部分，$i_{n, right}$ 表示 $i_n$ 的右半部分。由序列特性可知：\n$$\n\\left \\{\n\\begin{array}{ll}\ni_{n, left} \u0026amp; = i_{n-1} \\\\\ni_{n, right} \u0026amp; = i_{n-1} + 2^{n}\n\\end{array}\n\\right.\n$$ $x_n$ 表示长度为 $N$ 的序列，是将 $i_n$ 奇偶二分得到的序列，其中$n = log_2^N - 1$。 $x_0 = [0, 1]$。 $x_{n, left}$表示 $x_n$ 的左半部分，$x_{n, right}$ 表示 $x_n$ 的右半部分。 结合约定，这个证明问题写成：证明$x_n = BR(i_n, n+1)$。现在开始证明吧。\n后续数学公式中，使用乘2、除2代替左移1位、右移1位。\nstep 1:\n从迭代的初始值开始验证倒位序是否满足。当序列长度位2，$log_2^N = 1$ 时：\n序列 值 二进制 $i_0$ [0, 1] [0b, 1b] $x_0$ [0, 1] [0b, 1b] 由结果可知: $x_0 = BR(i_0, 1)$。\nstep 2:\n当序列长度为4，$log_2^N = 2$ 时:\n序列 值 二进制 $i_1$ [0, 1, 2, 3] [00b, 01b, 10b, 11b] $x_1$ [0, 2, 1, 3] [00b, 10b, 01b, 11b] 通过二进制可以看出，序列满足 $x_1 = BR(i_1, 2)$。但是这里要用利用递推关系来证明，才能推广到无限。\n再复习一下前面序列的数学关系，有：\n$$\n\\left \\{\n\\begin{array}{ll}\ni_{1, left} \u0026amp; = i_{0} \\\\\ni_{1, right} \u0026amp; = i_{0} + 2^{1} \\\\\nx_{1, left} \u0026amp; = x_{0} * 2 \\\\\nx_{1, right} \u0026amp; = x_{0} * 2 + 1 \\\\\n\\end{array}\n\\right.\n$$\n证明左半序列，\n由于$BR(i_{1, left}, 2) = BR(i_{0}, 2)$ ，\n根据倒位数性质5， 得$BR(i_{0}, 2) = BR(i_{0}, 1) * 2$，\n又 $\\because x_0 = BR(i_0, 1)$，\n$\\therefore BR(i_{0}, 1) * 2 = x_0 * 2 = x_{1, left}$\n证明右半序列，\n由于$BR(i_{1, right}, 2) = BR(i_{0} + 2^1, 2)$ ，\n根据倒位数性质6， 得$BR(i_{0} + 2^1, 2) = BR(i_{0}, 2) + 1$，\n根据倒位数性质5， 得$BR(i_{0}, 2) + 1 = BR(i_{0}, 1) * 2 + 1$，\n又 $\\because x_0 = BR(i_0 , 1)$，\n$\\therefore BR(i_{0}, 1) * 2 + 1 = x_0 * 2 + 1 = x_{1, right}$\n左半序列和右半序列分别得证，所以证得：\n$x_1 = BR(i_1, 2)$\nstep 3:\n将证明推广到 $n$ 与 $n-1$的关系，有：\n$$\n\\left \\{\n\\begin{array}{ll}\ni_{n, left} \u0026amp; = i_{n-1} \\\\\ni_{n, right} \u0026amp; = i_{n-1} + 2^{n} \\\\\nx_{n, left} \u0026amp; = x_{n-1} * 2 \\\\\nx_{n, right} \u0026amp; = x_{n-1} * 2 + 1 \\\\\nx_{n-1} \u0026amp; = BR(i_{n-1}, n)\n\\end{array}\n\\right.\n$$\n证明左半序列，\n由于$BR(i_{n, left}, n+1) = BR(i_{n-1}, n+1)$ ，\n根据倒位数性质5， 得$BR(i_{n-1}, n+1) = BR(i_{n-1}, n) * 2$，\n又 $\\because x_{n-1} = BR(i_{n-1}, n)$，\n$\\therefore BR(i_{n-1}, n) * 2 = x_{n-1} * 2 = x_{n, left}$\n证明右半序列，\n由于$BR(i_{n, right}, n+1) = BR(i_{n-1} + 2^n, n+1)$ ，\n根据倒位数性质6， 得$BR(i_{n-1} + 2^n, n+1) = BR(i_{n-1}, n+1) + 1$，\n根据倒位数性质5， 得$BR(i_{n-1}, n+1) + 1 = BR(i_{n-1}, n) * 2 + 1$，\n又 $\\because x_{n-1} = BR(i_{n-1} , n)$，\n$\\therefore BR(i_{n-1}, n) * 2 + 1 = x_{n-1} * 2 + 1 = x_{n, right}$\n左半序列和右半序列分别得证，所以证得：\n$x_{n} = BR(i_{n}, n+1)$\n至此证毕。\n实现BR() 没有什么技巧，基本思路就是从原数的低位开始找1，找到1时，倒位数就追加为1的位，否则追加为0的位。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def bit_reverse(n, log2N): if n \u0026gt;= (2**log2N): print(\u0026#34;ERR: can\u0026#39;t use %d bit to present number %d\u0026#34; % (log2N, n)) return 0 n_br = 0 for _ in range(log2N): n_br \u0026lt;\u0026lt;= 1 if (n \u0026amp; 1 != 0): n_br = n_br + 1 n \u0026gt;\u0026gt;= 1 return n_br # 改进版 def bit_reverse_inproved(n, log2N): if n \u0026gt;= (2**log2N): print(\u0026#34;ERR: can\u0026#39;t use %d bit to present number %d\u0026#34; % (log2N, n)) return 0 n_br = 0 pos = 0 while (n != 0): n_br \u0026lt;\u0026lt;= 1 if (n \u0026amp; 1 != 0): n_br = n_br + 1 n \u0026gt;\u0026gt;= 1 pos += 1 # 主要改进点是这里，免掉`bit_reverse()`中的剩余的循环 n_br = n_br \u0026lt;\u0026lt; (log2N - pos) return n_br if __name__ == \u0026#39;__main__\u0026#39;: n = 6 log2N = 3 print(\u0026#34;br(%d, %d) = %d\u0026#34; % (n, log2N, bit_reverse(n, log2N))) print(\u0026#34;br(%d, %d) = %d\u0026#34; % (n, log2N, bit_reverse_inproved(n, log2N))) 算法的时间花费主要在循环中。bit_reverse()固定循环log2N次。bit_reverse_inproved()的循环次数取决于二进制表示时最高位1的位置。\n实现倒位序 我们可以通过使用上面的bit_reverse()函数，对序列的每一位求倒位数。\n但这里介绍另一个改进版本，主要利用有序序列+1进位的特点：\n索引为n位置的数，是在索引为n-1位置的数的基础上+1进位。 二进制+1进位，原数从右到左进位，倒位数是从左到右进位的。 我们先描述原数进位的计算机操作，因为这最符合我们的惯性思维：二进制从右到左，如果找到0，就将它置为1，算法结束。如果找到1，就将它置为0，然后继续从右到左找下一位。循环这个步骤。\n倒位数的进位，操作方法一样，只不过方向改为从左到右。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def bit_reverse_carry(n, log2N): # 1的倒位数，用作进位的位置。二进制从左到右找 br_1 = 1 \u0026lt;\u0026lt; (log2N - 1) while ((n \u0026amp; br_1) != 0): # 将1改为0 n = n \u0026amp; (~br_1) # 准备找下一位的位置 br_1 \u0026gt;\u0026gt;= 1 # 将0改为1 n = n | br_1 return n def seq_bit_reverse(seq, log2N): # 倒位序中，首、尾的数不变，所以循环不覆盖 for i in range(1, N - 2): seq[i] = bit_reverse_carry(seq[i-1], log2N) if __name__ == \u0026#39;__main__\u0026#39;: log2N = 4 N = 2 ** log2N seq = list(range(N)) print(seq, sep=\u0026#39;,\u0026#39;) seq_bit_reverse(seq, log2N) print(seq, sep=\u0026#39;,\u0026#39;) 算法bit_reverse_carry()之所以减少了运算复杂度，相对于bit_reverse_inproved()主要是算法循环直到遇到0就结束了，而不是循环到最高位1。\n按索引位置看循环次数，当数为2的整数倍时，循环0次；索引位置为4倍+1时；循环1次，索引位置为8倍+3时，循环2次；依次类推，有：\n有N个数都会发生0改1 有N/2个数发生1次1改0 有N/4个数发生2次1改0 有N/8个数发生3次1改0 \u0026hellip; 有N/N个数发生log2N次1改0。(虽然首尾的数忽略了，但这里还是算进来，方便求值) 总共为:\n0改1次数：$N$ 1改0次数：$( \\frac N 2 \\times 1 + \\frac N 4 \\times 2 + \\frac N 8 \\times 3 + \u0026hellip; + \\frac N {2^{log_2^N}} \\times log_2^N ) = \\sum\\limits_{n = 1}^{log_2^N} \\frac {N} {2^n} \\times n$ 因为 $\\lim_{n \\rightarrow \\infty} \\frac {N} {2^n} \\times n = 0$, 所以1改0的次数逐渐趋于常量($C$)。因此，算法时间复杂度为$O(N)$。\n重排 上面的倒位序是重排的特例，因为原序列位置索引上的数，等于索引位置。\n倒位序重排，简单的说，对于一个数列中的每一个数值(可以为数、字串、或其它)，按所在的位置的倒位数重新放置，最终得到新的序列。\n举个例子，有8个字符，从a-h。原序列为：\n原序列 - - - - - - - - 原序列 a b c d e f g h 位置 0 1 2 3 4 5 6 7 位置的二进制 000 001 010 011 100 101 110 111 重排后：\n倒位数重排序列 - - - - - - - - 重排序列 a e c g b f d h 位置 0 4 2 6 1 5 3 7 位置的二进制 000 100 010 110 001 101 011 111 重排的代码实现也不多说了，根据前面实现倒位序来理解下面代码(主要来自几个快速傅立叶变换算法)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;stdio.h\u0026gt; void reverse2(int *data,int Log2N) { int i,j; int RevNum; int MaxPos,CurPos,MaxValue; int temp; MaxValue=(1\u0026lt;\u0026lt;Log2N)-1; MaxPos=1\u0026lt;\u0026lt;(Log2N-1); RevNum=0; for(i=1;i\u0026lt;MaxValue;i++) { CurPos=MaxPos; while((CurPos\u0026amp;RevNum)!=0) { RevNum=RevNum\u0026amp;(~CurPos); CurPos=CurPos\u0026gt;\u0026gt;1; } RevNum=RevNum|CurPos; // i相当于倒位数原数，只需要将倒位数小于原数的值交换。 // 也可以改成大于原数的值交换。 // 如果不加条件，两次交换相当于a\u0026lt;-\u0026gt;b，然后b\u0026lt;-\u0026gt;a，交换成原状态了。 if (RevNum\u0026gt;i) { temp=data[RevNum]; data[RevNum]=data[i]; data[i]=temp; } } } int main(int argc, char* argv[]) { int a[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}; int log2N = 4; reverse2(a, log2N); for (int i = 0; i \u0026lt; (1\u0026lt;\u0026lt;log2N); i++) printf(\u0026#34;%d \u0026#34;, a[i]); printf(\u0026#34;\\n\u0026#34;); return 0; } 问题延伸 前文的奇偶二分是一种“基2(Radix 2)”的倒位序重排，其中“2”表示以2为进制。除了基2的，还有基4(Radix 4)的，基n的。\n基4倒位序 基4要求序列长度是4的$n$次幂，$n$为正整数。假设序列为[0, 1, ..., N-1]，重排时，将$4n$位置的数依次放在最左边第1块，将$4n+1$的数依次放在第2块，$4n+2$放第3块，$4n+3$放第4块。然后对每块再反复做分块。\n比如一个长度为16的序列：\n原序列 原序列2进制 原序列4进制 结果序列 结果序列2进制 结果序列4进制 0 0000 00 0 0000 00 1 0001 01 4 0100 10 2 0010 02 8 1000 20 3 0011 03 12 1100 30 4 0100 10 1 0001 01 5 0101 11 5 0101 11 6 0110 12 9 1001 21 7 0111 13 13 1101 31 8 1000 20 2 0010 02 9 1001 21 6 0110 12 10 1010 22 10 1010 22 11 1011 23 14 1110 32 12 1100 30 3 0011 03 13 1101 31 7 0111 13 14 1110 32 11 1011 23 15 1111 33 15 1111 33 从上表中看出4进制的倒位了吗？可以看出“倒位”的这个“位”不是1个bit位，而是以2个bit为单位了。\n混合基倒位序 主要内容来自《数字信号处理教程》程佩青 第4版，章节为“N为复合数的FFT算法\u0026ndash;混合基（多基多进制）FFT算法”。\n在序列重排过程中，使用不同的步长进行分块操作。其中每个数，可以表示为多进制的数。\n当我们使用10进制时，表示为：\n$$\n(1949)_{10} = 1\\times 10^3 + 9\\times 10^2 + 4\\times 10^1 + 9\n$$\n再看混合基，当$N=r_0 r_1 \u0026hellip; r_{L-1}$，各$r_i(i=0,1,\u0026hellip;,L-1)$为大于1的正整数，则任一个$n\u0026lt;N$的正整数$n$，可以表示为多基多进制形式：\n$$\n(n)_{r_0 r_1 \u0026hellip; r_{L-1}} = (n_{L-1} n_{L-2} \u0026hellip; n_{1} n_{0})\n$$\n$$\n\\begin{array}{ll}\n(n)_{10} = \u0026amp; (r_0 r_1 \u0026hellip; r_{L-2})n_{L-1} + (r_0 r_1 \u0026hellip; r_{L-3})n_{L-2} + \u0026hellip; \\\\\n\u0026amp; + (r_0 r_1)n_2 + (r_0)n_1 + n_0\n\\end{array}\n$$\n其倒位序后为：\n$$\n(\\bar n)_{r_0 r_1 \u0026hellip; r_{L-1}} = (n_{0} n_{1} \u0026hellip; n_{L-2} n_{L-1})\n$$\n$$\n\\begin{array}{ll}\n(\\bar n)_{10} = \u0026amp; (r_1 r_2 \u0026hellip; r_{L-1})n_{0} + (r_1 r_2 \u0026hellip; r_{L-2})n_{1} + \u0026hellip; \\\\\n\u0026amp; + (r_{L-2} r_{L-1})n_{L-3} + (r_{L-1})n_{L-2} + n_{L-1}\n\\end{array}\n$$\n举例。一个长度为$N=30$的序列，使用$N=r_0 r_1 r_2 =5 \\times 3 \\times 2$的混合基：\n原序列 原序列(5,3,2)进制 结果序列 结果序列(2,3,5)进制 0 000 0 000 1 001 15 100 2 010 5 010 3 011 20 110 4 020 10 020 5 021 25 120 6 100 1 001 7 101 16 101 8 110 6 011 9 111 21 111 10 120 11 021 11 121 26 121 12 200 2 002 13 201 17 102 14 210 7 012 15 211 22 112 16 220 12 022 17 221 27 122 18 300 3 003 19 301 18 103 20 310 8 013 21 311 23 113 22 320 13 023 23 321 28 123 24 400 4 004 25 401 19 104 26 410 9 014 27 411 24 114 28 420 14 024 29 421 29 124 测试代码(可以在jupyter notebook中运行看看)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 x = list(range(0, 30)) def rev(data, radix_list): if len(radix_list) == 0: return data radix = radix_list[0] radix_list = radix_list[1:] final_data = [] for i in range(radix): # 按基挪位 tmp_data = data[i::radix] tmp_data = rev(tmp_data, radix_list) final_data += tmp_data return final_data # 结果序列 y = rev(x, [5, 3, 2]) import math # 按基表示一个数 def pn(n, radix_list): b = [] r = 0 for i in range(1, len(radix_list)): base = math.prod(radix_list[i:]) r = n // base b.append(r) n = n % base b.append(n) return \u0026#39;\u0026#39;.join([str(i) for i in b]) a = [pn(i, [5,3,2]) for i in x] print(*x, sep=\u0026#39;|\u0026#39;) print(*a, sep=\u0026#39;|\u0026#39;) # 基也倒过来了 b = [pn(i, [2,3,5]) for i in y] print(*y, sep=\u0026#39;|\u0026#39;) print(*b, sep=\u0026#39;|\u0026#39;) # 打印表格，方便md使用 xy = list(zip(x,a,y,b)) for i in xy: print(*i, sep=\u0026#39;|\u0026#39;) 总结 本文列出了暴力解法、kaldi中的迭代解法、倒位序重排，并给出了理论证明。最后介绍了基4和混合基。\n在重排算法中，我更喜欢kaldi中的解法，逻辑简单，代码简单，运算高效，只不过需要空间保存倒位序列。\n倒位序重排理论过程很巧妙，虽然算法时间复杂度也是$O(N)$，但有限数据下，算法效率相对弱一点点(从前面推导的时间复杂度式子可见)，并且代码逻辑有点绕。\n","description":"倒位序重排问题描述，数列规律和性质，求解方法。","id":0,"section":"ai","tags":["算法","排序","FFT"],"title":"倒位序重排","uri":"http://codebugs.pub/ai/alg/sort/bit_reverse_permutation/"},{"content":"2的整数次幂？ 2的整数次幂的特点 2的整数次幂的数，这里整数我们特指非负整数。\n数学表示为$ 2^n, n \\in N $，$ N $ 为非负整数（自然数）。我们看看这些数对应的二进制表示：\n2的整数次幂 幂次 二进制 $2 ^ 0 = 1$ 0 00000001 $2 ^ 1 = 2$ 1 00000010 $2 ^ 2 = 4$ 2 00000100 $2 ^ 3 = 8$ 3 00001000 $2 ^ 4 = 16$ 4 00010000 $2 ^ 5 = 32$ 5 00100000 $2 ^ 6 = 64$ 6 01000000 $2 ^ 7 = 128$ 7 10000000 可以看到，这些数的二进制表示只有一个1，其余位为0。在编程时，2的n次幂的数可以使用数字1左移n位，即1 \u0026lt;\u0026lt; n。\n如果将这个数减去1，便从最高的1位往下，全变为1了。用$2^3 = 8$举例：\n1 2 3 4 00001000 - 00000001 ----------- 00000111 判断一个数是否为2的n次幂 根据2的n次幂的二进制特点，我们可以知道，如果这个数x，与(x - 1)求逻辑与，结果为0时，则这个数时2的n次幂的数：\n1 2 def is_power_of_two(n): return not (n \u0026amp; (n - 1)) 但是，上面的程序遇到n = 0时，也认为它是2的n次幂的。所以需要改进一下：\n1 2 def is_power_of_two(n): return not (n \u0026amp; (n - 1)) and n 因为n为0的情况相对较少，所以把and n条件放在后面。\n用c语言写起来可能更清爽：\n1 2 int is_power_of_two(int n): return !(n \u0026amp; (n - 1)) \u0026amp;\u0026amp; n 较大的2的整数次幂的数 问题描述 求一个数临近的、且较大的2的整数次幂的数，示例：\n原数 原数的二进制 求解数 求解数的二进制 0 00000000 1 00000001 3 00000011 4 00000100 4 00000100 4 00000100 5 00000101 8 00001000 8 00001000 8 00001000 9 00001001 16 00010000 11 00001011 16 00010000 一个简单的求解方法 用python脚本举例：\n1 2 3 4 5 6 7 8 9 10 11 12 def simple_roundup(n): final_n = 1 tmp_n = n \u0026gt;\u0026gt; 1 while tmp_n != 0: final_n \u0026lt;\u0026lt;= 1 tmp_n \u0026gt;\u0026gt;= 1 if n \u0026gt; final_n: final_n \u0026lt;\u0026lt;= 1 return final_n 该方法是最容易想到的，利用二进制找最高位的1。原数右移一位，如果不为0，说明还有1，被求解数就左移一次。\n代码简单，但求解过程中运算次数不确定。比如输入0，while循环直接跳过；如果输入256，循环将执行8次。如果函数被大量调用，且输入都是更大的数，必然导致运算量增大。那么可以怎么优化呢？\n利用求解数特点来优化 先上代码，长得帅的可能一看就明白了。一段只支持8 bit表示的数（如果数更大，请手动扩展）：\n1 2 3 4 5 6 def roundup(n): n = n - 1 n |= n \u0026gt;\u0026gt; 1 n |= n \u0026gt;\u0026gt; 2 n |= n \u0026gt;\u0026gt; 4 return n + 1 边界0、会触及溢出的大数需要特殊处理。这个程序更多瞄准非边界的数。\n现在无论求什么数，只需要相同几步即可求解。\n用数字65来模拟代码运行，为了方便查看，我用-代替0：\n步骤 n n的二进制 n 65 -1-----1 n = n - 1 64 -1------ n |= n \u0026gt;\u0026gt; 1 96 -11----- n |= n \u0026gt;\u0026gt; 2 120 -1111--- n |= n \u0026gt;\u0026gt; 4 127 -1111111 n + 1 128 1------- 通过类似模拟，程序的基本思路就是先把数转化位-1111111的形式，最后+1得到10000000，即为所求。\n为了正确求解8、64等2的n次幂的数，第一行使用n = n - 1做一下适配。\n现在看为什么右移1、2、4呢？从表中可以看出（描述中所谓的最高位，特指从二进制表示时为1的高位开始算；保证n位为1特指如果从最高1位开始，如果还有n位的空余，那么这些空余位上都是1）：\nn |= n \u0026gt;\u0026gt; 1 保证数的最高2位都是1 n |= n \u0026gt;\u0026gt; 2 最高2位都是1，所以再右移2位，求或之后保证得到最高4位为1 n |= n \u0026gt;\u0026gt; 4 最高4位都是1，所以再右移4位，求或之后保证得到最高8位为1 如果是32 bit表示的数，那么追加n |= n \u0026gt;\u0026gt; 8 和n |= n \u0026gt;\u0026gt; 16。更大的数，以此类推。 这个问题的实际应用 为什么程序员要浪费时间来优化这个方法？求得2的n次幂的数又有什么用？难道仅仅是炫技好玩？又或者为了求职面试？\n其实最好用的场景就是取模运算。\n人类世界倾向与十进制计数，计算机基于电路开闭的基本设计，倾向于二进制计数。\n对于十进制世界的人类来说，求任意一个整数的相对于10的3次幂的模，比如7625 % (10^3)，只用取低位值625便可，非常简单。但对于计算机来说，这个计算会稍微麻烦一点。\n而让计算机求一个数相对于2的3次幂的模，比如14 % (2^3)，计算机也可以取最低3位值00001110 \u0026amp; (000001000 - 1) = 00001110 \u0026amp; 00000111 = 00000110 = 6。但对于人来说，求取又会麻烦一点。\n如果我们有一张hash表，需要快速的求key。对于人类来说，我们可以对1000取模，非常方便求取key值。对于计算机来说，对2 ^ 10取模，反而更容易求key。大家可能最容易接触到的场景，就是java的hashmap扩容使用了该方法。\nhash取模运算也通常使用素数求模，计算key的速度会慢一点，但是在实际应用中，面对未知数据，或者有潜在规律的数据时，一定程度上减少key冲突的情况，加快查询。这个后面单独写一篇个人见解。\n另外，有一些算法也会用到2的n次幂的数。比如一般的FFT快速傅里叶变换中，在分而治之的思想指导下，需要不断的将数据分成2等分。我也是看FFT相关代码才关注这个问题的。\n扩展：较小的2的整数次幂的数 借用求“较大”的数的思路，求“较小”的数怎么操作呢？\n我写了一段代码，同样要注意边界0、触及溢出的大数要特殊处理，这里只展示主体：\n1 2 3 4 5 6 def rounddown(n): n \u0026gt;\u0026gt;= 1 n |= n \u0026gt;\u0026gt; 1 n |= n \u0026gt;\u0026gt; 2 n |= n \u0026gt;\u0026gt; 4 return n + 1 好了，求较小的数有代码了，但我也不知道有什么用，我也不想了，头发快没有了。\n","description":"求一个数临近(较大/较小)的2的整数次幂的数的小技巧","id":1,"section":"ai","tags":["算法","神奇的数"],"title":"求一个数临近的2的整数次幂的数","uri":"http://codebugs.pub/ai/alg/number/round_power_of_2/"},{"content":"前言 乱码是一个让人头痛的问题，码虫们或多或少都会遇到。\n在度娘上搜答案，往往不能让开发者满意，我列出了一些外网搜索有帮助的关键词：\nunreadable characters gibberish garbled text mojibake 本文从我学习到工作的经历中，选择了一部分的有趣的乱码遭遇，供大家围观。\n[leo@leo-m ~]$ printf \u0026#34;\\U0001F92A\\U0001F92A\\U0001F92A\u0026#34; 🤪🤪🤪 电脑求救狂喊烫烫烫 这应该是每一个c/c++初学者高概率遇到过的问题。\n1 2 3 4 5 6 #include \u0026lt;iostream\u0026gt; int main() { char s[3] = {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;}; std::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; std::endl; } 使用visual studio 2019的Debug调试模式运行结果:\n我遇到这个问题时，天下还是windows xp的，开发环境使用的古老的vc++ 6.0。\n虽然这是一个典型问题，c/c++的字符串没有空结尾，导致输出了字符串后面的一段非法内存数据，但是为什么输出“烫烫烫”呢？\n作为小白的我，当然不会care这种问题，只管“照着正确的方式做就行了”。况且依当年的互联网环境可能也搜不出答案，就算是搜出答案，我也大概率看不懂。\n多年以后才明白，原来是visual studio在调试模式下，使用0xCC(INT3调试指令的操作码)标注未初始化的栈上内存，以方便错误检查。\n查看Why does the not allocated memory is marked like 0xCC?\n那么0xCC与“烫”是什么关系？其实“烫”的GBK编码就是0xCC 0xCC，在linux下我用两种方式展示字符编码与文字的转化：\n[leo@leo-m ~]$ echo -e \u0026#34;\\xcc\\xcc\u0026#34;|iconv -f gbk 烫 [leo@leo-m ~]$ echo -ne \u0026#34;烫\u0026#34; | iconv -t gbk | hexdump 0000000 cccc 0000002\n命令解释：\nman echo命令可以查看echo的帮助文档，-e是表示解析反斜杠转义符号（escape，这里就是指后面的\\x)，cc就是一个字节(BYTE)的编码，两个cc才能表示一个“烫”。这里可以使用echo输出，也可以使用printf命令。 man iconv命令可以查看iconv的帮助文档，-f表示指定输入的字符编码(不指定时，默认为本地locale环境所指定的编码)，-t表示转换后输出的编码。 |管道，表示左边命令的输出作为右边命令的标准输入(stdin)。 hexdump 以16进制显示数据，这里可以用xxd工具替换。两者都很好用。 Linux文件名乱码 第一次尝试学习使用Linux发行版本是ubuntu 8.04，没用虚拟机，傻傻地直接安装在笔记本上，加上校园网客户端对Linux的不友好，很折腾。\n各种不符合Win习惯的命令操作，加上移动硬盘上部分文件名乱码，直接把人整懵了。对于名声赫赫的Linux，我打心底觉得“真是难用”。\n古老的乱码问题不知道原因，也找不到具体环境了，但文件名乱码问题偶尔还是会遇到。比如在Windows下，我使用7z压缩文件夹test为test.zip，目录结构如下：\ntest ├── 中文名.txt ├── 中文文件夹 │ └── 中文1.txt └── xx.txt 在Linux上使用unzip解压，便出现了乱码：\n[leo@leo-m charset]$ unzip test.zip Archive: test.zip creating: test/ extracting: test/xx.txt extracting: test/╓╨╬─├√.txt creating: test/�����ļ���/ extracting: test/�����ļ���/����1.txt [leo@leo-m test]$ tree . ├── \\326\\320\\316\\304\\316\\304\\274\\376\\274\\320 │ └── \\326\\320\\316\\3041.txt ├── ╓╨╬─├√.txt └── xx.txt 1 directory, 3 files WTF? 都2021年了，这么基础的操作也乱码？\n这个问题也是字符编码与解码不一致造成的，在Win上7z压缩是使用GBK编码，而在本地Linux上，默认使用的utf-8解码。在Linux上查看本地编码设置：\n[leo@leo-m ~]$ echo $LANG zh_CN.UTF-8\n那么如何解决这个乱码问题呢？在archlinux有一个iconv的解压软件包unzip-iconv(其他发行版应该也有)，能够指定编码。\n使用unzip-iconv显示压缩包文件内容：\n[leo@leo-m test]$ unzip -O GBK -l ../test.zip Archive: ../test.zip Length Date Time Name --------- ---------- ----- ---- 0 2021-08-23 11:42 test/ 4 2021-08-19 10:13 test/xx.txt 9 2021-08-17 10:05 test/中文名.txt 0 2021-08-23 11:42 test/中文文件夹/ 0 2021-08-23 11:41 test/中文文件夹/中文1.txt --------- ------- 13 5 files\nWin下Python输出乱码 前面的乱码问题，都是小问题，就算遇到了，睁一只眼闭一只眼，继续吃的好睡得香。可是开发过程中遇到乱码问题不解决，老板是会打屁屁的。\n那时主流用python2，python3还不稳定，用的人少。平时在Windows上开发，最后运行在Linux上。有时，同样的代码，Win上出问题，Linux上完好。\n运行不了，出现\\xHH乱码 现在看例子（代码文件用utf-8格式保存），在Windows下运行python2：\n1 2 s = \u0026#34;中文\u0026#34; print(s) 运行出现错误，字符串出现了\\xHH：\nC:\\Users\\leo\\Desktop\\test\u0026gt;python main.py File \u0026#34;main.py\u0026#34;, line 1 SyntaxError: Non-ASCII character \u0026#39;\\xe4\u0026#39; in file main.py on line 1, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details\n好吧，此时我才知道utf8这种东西，以前最多停留在c/c++中char与wchar，visual studio里的多字节编码和Unicode，转码函数multibytetowidechar、mbstowcs这种基本使用上。\n我们先看中文的utf-8编码，第一个字节为\\xe4：\n[leo@leo-m ~]$ printf 中文|xxd 00000000: e4b8 ade6 9687 ......\n在python2时代，默认的字符串解析，使用ASCII编码，最大表示0x7F，遇到\\xe4自然不认识。查看码表：\n[leo@leo-m ~]$ ascii Usage: ascii [-adxohv] [-t] [char-alias...] -t = one-line output -a = vertical format -d = Decimal table -o = octal table -x = hex table -b binary table -h = This help screen -v = version information Prints all aliases of an ASCII character. Args may be chars, C \\-escapes, English names, ^-escapes, ASCII mnemonics, or numerics in decimal/octal/hex. Dec Hex Dec Hex Dec Hex Dec Hex Dec Hex Dec Hex Dec Hex Dec Hex 0 00 NUL 16 10 DLE 32 20 48 30 0 64 40 @ 80 50 P 96 60 ` 112 70 p 1 01 SOH 17 11 DC1 33 21 ! 49 31 1 65 41 A 81 51 Q 97 61 a 113 71 q 2 02 STX 18 12 DC2 34 22 \u0026#34; 50 32 2 66 42 B 82 52 R 98 62 b 114 72 r 3 03 ETX 19 13 DC3 35 23 # 51 33 3 67 43 C 83 53 S 99 63 c 115 73 s 4 04 EOT 20 14 DC4 36 24 $ 52 34 4 68 44 D 84 54 T 100 64 d 116 74 t 5 05 ENQ 21 15 NAK 37 25 % 53 35 5 69 45 E 85 55 U 101 65 e 117 75 u 6 06 ACK 22 16 SYN 38 26 \u0026amp; 54 36 6 70 46 F 86 56 V 102 66 f 118 76 v 7 07 BEL 23 17 ETB 39 27 \u0026#39; 55 37 7 71 47 G 87 57 W 103 67 g 119 77 w 8 08 BS 24 18 CAN 40 28 ( 56 38 8 72 48 H 88 58 X 104 68 h 120 78 x 9 09 HT 25 19 EM 41 29 ) 57 39 9 73 49 I 89 59 Y 105 69 i 121 79 y 10 0A LF 26 1A SUB 42 2A * 58 3A : 74 4A J 90 5A Z 106 6A j 122 7A z 11 0B VT 27 1B ESC 43 2B + 59 3B ; 75 4B K 91 5B [ 107 6B k 123 7B { 12 0C FF 28 1C FS 44 2C , 60 3C \u0026lt; 76 4C L 92 5C \\ 108 6C l 124 7C | 13 0D CR 29 1D GS 45 2D - 61 3D = 77 4D M 93 5D ] 109 6D m 125 7D } 14 0E SO 30 1E RS 46 2E . 62 3E \u0026gt; 78 4E N 94 5E ^ 110 6E n 126 7E ~ 15 0F SI 31 1F US 47 2F / 63 3F ? 79 4F O 95 5F _ 111 6F o 127 7F DEL\n修改编码，依旧乱码 既然是解析问题，我们让python2以utf-8来解析字符串，添加注释# -*- coding: utf-8 -*-：\n1 2 3 # -*- coding: utf-8 -*- s = \u0026#34;中文\u0026#34; print(s) 这次代码，在Linux上运行良好，但是在Win上奇奇怪怪：\nC:\\Users\\leo\\Desktop\\test\u0026gt;python main.py 涓枃\n看着屏幕上自己的倒影，蹭亮的脑袋格外显眼，虽然物抗法抗反甲与生俱来，但是连机器世界的大佬都骗人，我们还要怎么做才能防火防盗防师妹呢？说好的跨平台，说好的移植性好呢？\n然后内心防线崩溃了，开始口吐芬芳。支持个中文这么难，就像很多开源工具一样，“文件路径”不能有“空格”，不能有“中文”，python2看来也是“美帝良心”。\n其实，这个问题也不是中文出现，在谷歌上，拥有世界的大韩民族，小日子过得还不错的大和民族，都跟爱嘲讽的我们一样。整个世界的非英语国家都受到了暴击。\n网上最流行的方案，也是最合适的方案，就是标注字符串为unicode string：\n# -*- coding: utf-8 -*- s = u\u0026#34;中文\u0026#34; print(s) 现在问题解决了，看起来也是编码问题，这个原因要怎么理解？\nWin上默认使用GBK编码，命令行中使用chcp命令，查看代码页(Code page，代码页其实就是在Win、IBM等系列产品下，字符编码的另一套框架实现。cp936与GBK一个是从实现框架上说，一个是字符集映射上来说，但我们简单将cp936看作是GBK编码的)：\nC:\\Users\\leo\\Desktop\\test\u0026gt;chcp 活动代码页: 936\n而Linux上使用UTF-8编码：\n[leo@leo-m ~]$ echo $LANG zh_CN.UTF-8\n看到环境不一样，就能想到差异的由来：\n代码中虽然指定了coding: utf-8，但只是告诉python2如何来认识代码脚本。我们的代码文件是使用utf-8格式保存的，那就应该用utf-8来解析，不要看到越界（0 - 127, ASCII）的字符就报错。这就是使用coding: utf-8的目的。 字符串中文在内存中虽然以utf-8的数据表示(0xe4 0xb8 0xad 0xe6 0x96 0x87) 但是在Win上使用(比如显示、打印字符)时，根据当前代码页设置，又使用GBK编码来映射字符，所以乱码了。 在Linux上，当前编码同样是utf-8，所以不会乱码。如果不是utf-8，乱码也会出现。 我们可以验证下，确认中文的utf-8数据，用GBK编码解析看到相同的乱码：\n[leo@leo-m ~]$ printf \u0026#34;中文\u0026#34;|iconv -f GBK -c 涓枃\n在Linux上模拟乱码 使用LANG=zh_CN.gbk xterm命令，目地是使用zh_CN.gbk编码上下文，打开一个新的xterm终端。注意不要直接在xterm中用export LANG=zh_CN.gbk修改环境，这样没有效果，因为xterm本身不在这个环境变量下。\n[leo@leo-m ~]$ echo $LANG zh_CN.gbk [leo@leo-m ~]$ [leo@leo-m ~]$ python2 /tmp/main.py 涓枃 其他解决办法 其他解决办法类似，这里提出来，只是帮助理解这个乱码问题。\n使用unicode() 1 2 3 # -*- coding: utf-8 -*- s = unicode(\u0026#34;中文\u0026#34;, \u0026#34;UTF-8\u0026#34;) print(s) 使用unicode()函数创建了个unicode string。\n使用decode() 1 2 3 # -*- coding: utf-8 -*- s = \u0026#34;中文\u0026#34;.decode(\u0026#34;UTF-8\u0026#34;) print(s) 将utf-8编码的中文，使用utf-8解码为新的unicode string。\n使用gbk编码 1 2 3 # -*- coding: gbk -*- s = \u0026#34;中文\u0026#34; print(s) 将coding改为gbk，最后使用GBK编码保存文件。\n网页显示乱码 有了python2的一段乱码经历，对于解决乱码问题，知道一个编码要与解码对应起来。现在觉得这个问题简单，但以前知识太薄，解决乱码很迷茫。\n几年前，同事写了个网页，遇到了乱码，我拿起utf-8的刀子就开始切，最后还是受到了社会无情的鞭打。\n在Win上，使用gbk保存的一段html网页代码：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt; this is 中文\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; this is yingwen \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这个乱码很简单，Win上很多工具默认的文件编码为gbk，所以指定charset=\u0026quot;UTF-8\u0026quot;解码不正确。\n两种解决办法：\n一，将文件用utf-8格式保存。推荐。\n二，继续用gbk保存，把代码中的charset指定为gbk。\n网站系统前后端交互乱码 这是两年前遇到的问题，后端对字符串一个字节一个字节地做异或、乱序、base64/unbase64等操作，然后前端js逆向操作解码出字符串。操作很简单，但是中文出现乱码。\n后端使用openresty代替nginx，虽然其它后端语言一样会出现这个问题，但我还是拿原来的环境来说明。\nnginx通常被用做静态网站的容器，以及反向代理的网关。openresty在nginx基础上，添加了lua脚本的支持，使之有动态内容的处理能力。比如在高并发网站系统中，与redis结合，形成后端系统的第一层缓存。\n搭建openresty 这里我们测试时，可以使用docker来简单搭建环境，端口使用18880：\ndocker run -d --name openresty -p 18880:80 \\ -v /opt/docker/openresty/conf.d:/etc/nginx/conf.d \\ openresty/openresty:alpine 用lua在基础配置上添加一段location，返回一段字符串。（基础配置default.conf）如下：\n1 2 3 4 5 6 7 8 9 10 11 12 server { listen 80; server_name localhost; ... location /test { content_by_lua \u0026#39; ngx.say(\u0026#34;hello 看看中文 world\u0026#34;); \u0026#39;; } ... 将配置文件放置到/opt/docker/openresty/conf.d/目录下。docker restart openresty重启openresty。\nlinux终端下，测试后端配置正确，能正常访问：\n[leo@leo-m ~]$ curl http://localhost:18880/test 2\u0026gt;/dev/null hello 看看中文 world 测试成功后，先在浏览器访问http://localhost:18880，之后在调试窗口中才可以发起同源地址的请求。在浏览器调试窗口中发起请求：\n1 2 3 fetch(\u0026#39;http://localhost:18880/test\u0026#39;) .then( resp =\u0026gt; resp.text()) .then( t =\u0026gt; console.info( t )) 返回结果正常。\n复现问题 将default.conf配置中\n1 ngx.say(\u0026#34;hello 看看中文 world\u0026#34;); 添加base64编码，改为\n1 ngx.say(ngx.encode_base64(\u0026#34;hello 看看中文 world\u0026#34;)); 重启openresty后(docker restart openresty)，终端中测试请求并解码：\n[leo@leo-m ~]$ curl http://localhost:18880/test 2\u0026gt;/dev/null aGVsbG8g55yL55yL5Lit5paHIHdvcmxk [leo@leo-m ~]$ curl http://localhost:18880/test 2\u0026gt;/dev/null \\ | base64 --decode hello 看看中文 world\n测试成功后，在浏览器调试窗口中发起请求应使用atob解码：\n1 2 3 fetch(\u0026#39;http://localhost:18880/test\u0026#39;) .then( resp =\u0026gt; resp.text()) .then( t =\u0026gt; console.info( atob(t) )) 中文显示乱码：\nhello ççä¸­æ world 问题来了，为什么不使用base64时，中文正常显示，加上后却乱码了？眼花了，还是神经错乱？\n现在知道为什么程序员虽是“农名工”却要拿高工资了吧？颈椎病事小，精神出问题事大。\n乱码原因 还得搬出“编码不匹配”这把屠龙宝刀。\n后端发送数据是utf-8编码，那么js的字符串使用什么编码？答案是utf-16(What is the default JavaScript character encoding)。\n不加base64时为什么显示正常 简单一句话（在MDN上有明确描述Response.text()），在text()函数中，默认按utf-8编码转码了请求的返回数据。\n但是我没有找到fetch发送数据时，转码为utf-8的描述。大佬不说，我就手动抓包测试一下。\n准备发送数据的代码：\n1 2 3 4 5 6 7 8 fetch(\u0026#39;http://localhost:18880/test\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#34;Content-type\u0026#34;: \u0026#34;text/plain; charset=UTF-8\u0026#34;, }, body: \u0026#39;中文***************************************\u0026#39; }) .then(resp =\u0026gt; resp.text()) 然后开启抓包（因为服务在本地，访问时也使用localhost，所以抓包的网络接口为lo的回环网口），再发送数据，得到：\n[leo@leo-m ~]$ sudo tcpdump -A -X \u0026#34;tcp port 18880\u0026#34; -i lo ... 0x0000: 4500 02d8 7a25 4000 4006 bff8 7f00 0001 E...z%@.@....... 0x0010: 7f00 0001 96e6 49c0 cb75 9300 df86 66d9 ......I..u....f. 0x0020: 8018 0200 00cd 0000 0101 080a 97a0 1f94 ................ 0x0030: 97a0 1f94 504f 5354 202f 7465 7374 2048 ....POST./test.H 0x0040: 5454 502f 312e 310d 0a48 6f73 743a 206c TTP/1.1..Host:.l 0x0050: 6f63 616c 686f 7374 3a31 3838 3830 0d0a ocalhost:18880.. 0x0060: 5573 6572 2d41 6765 6e74 3a20 4d6f 7a69 User-Agent:.Mozi 0x0070: 6c6c 612f 352e 3020 2858 3131 3b20 4c69 lla/5.0.(X11;.Li 0x0080: 6e75 7820 7838 365f 3634 3b20 7276 3a39 nux.x86_64;.rv:9 0x0090: 312e 3029 2047 6563 6b6f 2f32 3031 3030 1.0).Gecko/20100 0x00a0: 3130 3120 4669 7265 666f 782f 3931 2e30 101.Firefox/91.0 0x00b0: 0d0a 4163 6365 7074 3a20 2a2f 2a0d 0a41 ..Accept:.*/*..A 0x00c0: 6363 6570 742d 4c61 6e67 7561 6765 3a20 ccept-Language:. 0x00d0: 656e 2d55 532c 656e 3b71 3d30 2e35 0d0a en-US,en;q=0.5.. 0x00e0: 4163 6365 7074 2d45 6e63 6f64 696e 673a Accept-Encoding: 0x00f0: 2067 7a69 702c 2064 6566 6c61 7465 0d0a .gzip,.deflate.. 0x0100: 5265 6665 7265 723a 2068 7474 703a 2f2f Referer:.http:// 0x0110: 6c6f 6361 6c68 6f73 743a 3138 3838 302f localhost:18880/ 0x0120: 0d0a 436f 6e74 656e 742d 5479 7065 3a20 ..Content-Type:. 0x0130: 7465 7874 2f70 6c61 696e 3b63 6861 7273 text/plain;chars 0x0140: 6574 3d55 5446 2d38 0d0a 4f72 6967 696e et=UTF-8..Origin 0x0150: 3a20 6874 7470 3a2f 2f6c 6f63 616c 686f :.http://localho 0x0160: 7374 3a31 3838 3830 0d0a 436f 6e74 656e st:18880..Conten 0x0170: 742d 4c65 6e67 7468 3a20 3435 0d0a 436f t-Length:.45..Co 0x0180: 6e6e 6563 7469 6f6e 3a20 6b65 6570 2d61 nnection:.keep-a 0x0190: 6c69 7665 0d0a 436f 6f6b 6965 3a20 6578 live..Cookie:.ex 0x01a0: 7065 7269 6d65 6e74 6174 696f 6e5f 7375 perimentation_su 0x01b0: 626a 6563 745f 6964 3d49 6a67 305a 6a5a bject_id=Ijg0ZjZ 0x01c0: 6959 6a4d 784c 5751 3259 546b 744e 4745 iYjMxLWQ2YTktNGE 0x01d0: 334d 4330 344f 5445 794c 5467 3059 5749 3MC04OTEyLTg0YWI 0x01e0: 304e 546b 3259 7a45 795a 4349 2533 442d 0NTk2YzEyZCI%3D- 0x01f0: 2d65 3961 3363 6465 3666 6361 3764 6265 -e9a3cde6fca7dbe 0x0200: 3036 6136 6437 6132 6533 3137 3062 6235 06a6d7a2e3170bb5 0x0210: 6238 6639 3932 3761 333b 2073 6964 6562 b8f9927a3;.sideb 0x0220: 6172 5f63 6f6c 6c61 7073 6564 3d66 616c ar_collapsed=fal 0x0230: 7365 0d0a 5365 632d 4665 7463 682d 4465 se..Sec-Fetch-De 0x0240: 7374 3a20 656d 7074 790d 0a53 6563 2d46 st:.empty..Sec-F 0x0250: 6574 6368 2d4d 6f64 653a 2063 6f72 730d etch-Mode:.cors. 0x0260: 0a53 6563 2d46 6574 6368 2d53 6974 653a .Sec-Fetch-Site: 0x0270: 2073 616d 652d 6f72 6967 696e 0d0a 5072 .same-origin..Pr 0x0280: 6167 6d61 3a20 6e6f 2d63 6163 6865 0d0a agma:.no-cache.. 0x0290: 4361 6368 652d 436f 6e74 726f 6c3a 206e Cache-Control:.n 0x02a0: 6f2d 6361 6368 650d 0a0d 0ae4 b8ad e696 o-cache......... 0x02b0: 872a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a .*************** 0x02c0: 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a 2a2a **************** 0x02d0: 2a2a 2a2a 2a2a 2a2a ******** ...\n看到最后几行，****前面的字节（...e696 87...），确实是utf-8编码：\n[leo@leo-m ~]$ printf \u0026#39;\\xe6\\x96\\x87\u0026#39; 文\n看来发送时，也会默认把utf-16编码转为utf-8。\n为什么乱码 看到乱码，像是西欧字符，并且与Extended ASCII中字符相对应。latin系列就是玩西欧字符的，那就在终端中测试latin1解码这个utf-8数据：\n[leo@leo-m ~]$ printf \u0026#34;hello 看看中文 world\u0026#34;|iconv -f latin1 hello ççä¸­æ world\nprintf是在zh_CN.UTF-8编码下输出的数据，在用latin1来解析这段数据，得到相同的乱码文字。\n看看中文的utf-8编码:\n[leo@leo-m conf.d]$ printf 看看中文| xxd 00000000: e79c 8be7 9c8b e4b8 ade6 9687 ............\n再看看第一个字节\\xe7，在浏览器调试窗口中，我们输入\u0026quot;\\xe7\u0026quot;，可以看到对应的ç乱码。\natob解码后，应该是还原了utf8的编码数据。\n但是，上面不是说js用utf-16来识别这段数据吗，应该得到如下的乱码呀：\n[leo@leo-m ~]$ printf \u0026#39;hello 看看中文 world\u0026#39;|iconv -f UTF-16 敨汬⁯鳧讜룤螖眠牯摬\n这又是为什么呢？\n其实atob解码后，将数据按BYTE填充UTF-16的双字节，类似与下面一段操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var s_u8 = [ 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0xe7, 0x9c, 0x8b, 0xe7, 0x9c, 0x8b, 0xe4, 0xb8, 0xad, 0xe6, 0x96, 0x87, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64] var arr = new Uint16Array(s_u8.length) for (var i = 0; i \u0026lt; s_u8.length; i++) { arr[i] = s_u8[i] } var s_u16 = \u0026#39;\u0026#39;; for (var i = 0; i \u0026lt; arr.length; i++) { s_u16 += String.fromCharCode(arr[i]); } console.info(s_u16) 其中s_u8为看看中文的utf-8编码，其中每个字节都会对应到utf-16的单个字符（一个字符占两字节）。最终得到那串乱码：\n然后又有一个问题，utf-16怎么就显示latin1字符了？其实utf-16是latin1编码扩展，前者的低字节部分就是后者的编码。\n[leo@leo-m ~]$ printf \u0026#39;\\u00e7\u0026#39; ç 修复乱码 修复该乱码问题，主要是实现utf-8到utf-16转码，可以手动写，也可以用TextDecoder()，但要考虑浏览器兼容性。\n1 2 3 4 5 6 7 8 9 10 11 12 fetch(\u0026#39;http://localhost:18880/test\u0026#39;) .then(resp =\u0026gt; resp.text()) .then(t =\u0026gt; atob(t)) .then(t =\u0026gt; { var decoder = new TextDecoder(\u0026#39;utf-8\u0026#39;); var arr = new Uint8Array(t.length); for (var i = 0; i \u0026lt; arr.length; i++) { arr[i] = t.charCodeAt(i); } return decoder.decode(arr); }) .then(t =\u0026gt; console.log(t)) 操作说明：\n使用Uint8Array，还原utf-8的字符串Buffer。 使用TextDecoder转码。 最后 乱码问题定位，即简单又复杂。它可能有多个原因：\n有些乱码可能不是乱码，只是一种特殊字串。比如浏览器地址的中特殊字符转义(对应ASCII值)：%3d表示=。比如linux终端的颜色格式化：\\033[1;31mred text\\033[0m用于输出红色的red text。 数据本身不是合法字符，所有编码都不能表示它。 编码不匹配。编码与解码不匹配，数据与显示环境解码不匹配。文件数据可以使用chardet工具来猜测编码。通过换编码、换工具等来解决。 字体不支持。西欧字体不支持中文显示，字体不支持emoji表情字体等。通过换字体、换工具来解决。 参考资料 打不开链接的，请科学上网。\nWhy does the not allocated memory is marked like 0xCC? Character encoding - Wikipedia INT_(x86_instruction) Python2 unicode Python2 unicode string Code page - Wikipedia Code page 936 - Wikipedia Code page identifiers Extended ASCII - Wikipedia What is the default JavaScript character encoding ","description":"看见乱码，心乱如麻？我的乱码遭遇，可能你也遇到了！","id":4,"section":"lang","tags":["字符编码"],"title":"乱码了？-- 我的乱码遭遇史","uri":"http://codebugs.pub/lang/common/charenc/myexp/"},{"content":"初识 #! 我们经常在一些脚本的第一行看到#!开头的一段注释，例如在shell脚本中：\n1 2 #!/usr/bin/bash echo hello world! 在python脚本中：\n1 2 #!/usr/bin/python print(\u0026#34;hello world!\u0026#34;) 在我们熟知的几种脚本语言中，#一般被用作单行注释。但在类Unix环境下，第一行的#!还有另外一层意义：它告诉操作系统(程序加载器，即 program loader)，在运行脚本时，使用哪一个解析指令(interpreter directive)来处理脚本。这一行特殊注释，称为shebang，也叫做sh-bang、sha-bang、hashbang、pound-bang、hash-bang。\n在上面的示例中，shebang指明分别使用/usr/bin/bash和/usr/bin/python来分别运行shell和python脚本，最终打印hello world!。\nshebang 定义 shebang的格式：\n1 #!interpreter [optional-arg] 其中：\nshebang必须出现在脚本第一行，且顶格。 interpreter是一个可执行程序，并用绝对路径或者基于当前工作目录的相对路径写明。这里可执行程序的定义在不同操作系统上定义不同。在Linux中，可执行程序是指具有可执行权限的、可以直接运行的程序，可以是可执行二进制程序，也可以是脚本。在Solaris-和Darwin-的衍生操作系统中(比如MacOS)，可执行程序是指可执行的二进制程序，而不能是脚本。 #!与interpreter之间可以有空格，但通常不使用空格。 可以传递多个参数。 调用示例 在/tmp/目录下新建shebang目录，目录结构：\n1 2 3 shebang ├── myscript_a └── myscript_b myscript_a：\n1 2 3 #!/usr/bin/bash echo $1 cat $1 myscript_b：\n1 2 #!/tmp/shebang/myscript_a echo hello world 在myscript_a使用bash作为解析指令，输出第一个参数，并且显示对应文件内容。\n在myscript_b使用myscript_a作为解析指令，最终会当作文本显示全部内容。\n先添加脚本的可执行权限，然后执行：\n[leo@leo-m shebang]$ chmod +x myscript_* [leo@leo-m shebang]$ ./myscript_b ./myscript_b #!/tmp/shebang/myscript_a echo hello world\n我们可以看到，脚本的运行效果如同脚本的直接调用：\n[leo@leo-m shebang]$ ./myscript_a ./myscript_b ./myscript_b #!/tmp/shebang/myscript_a echo hello world\n使用env的shebang 使用env的目的 env作为一个命令，经常被用来列举当前用户的所有环境变量。而我们也常在shebang中使用它。\n拿python脚本举例，这种写法也经常出现：\n1 #!/usr/bin/env python 虽然最终都是使用python来解析脚本，那么它跟#!/usr/bin/python有何区别呢？\n其实，使用env的方式，只是比直接指定路径的方式，多了一些灵活性。env会在环境变量PATH中查找python所在路径，最终使用找到的第一个python来解析脚本。我们可以使用echo $PATH在终端查看自己的PATH目录。\n使用env的方式，最大的优势就是实现不同环境上的兼容性。因为在不同的系统中，python等可执行程序可能存在的目录不一样。举个例子，python可能放在/usr/bin下，或者/opt/python、$HOME/python等目录（当然这些目录需要添加到PATH环境变量中，env才能找到），如果直接指定指定/usr/bin/python导致找不到python，最终无法正常执行。\n使用env也有一个小风险，就是恶意人士可能在PATH目录下放置一个同名的假程序，脚本执行时就会运行这个恶意程序。当然这个操作需要一定的权限(比如root、或者其它具有sudo等授权)，当他都拥有了这种权限之后，可能也不屑于做这样的事了。\nenv 的shebang定义 1 2 #!/usr/bin/env command #!/usr/bin/env -[v]S[option]… [name=value]… command [args]… 我们看个容易出错误的地方，用perl作例子，文件名hello.pl：\n1 2 #!/usr/bin/env perl -T -w print \u0026#34;hello\\n\u0026#34;; 脚本只是输出hello，但尝试运行时出错：\n[leo@leo-m shebang]$ chmod +x hello.pl [leo@leo-m shebang]$ ./hello.pl /usr/bin/env: “perl -T -w”: 没有那个文件或目录 /usr/bin/env: 使用 -[v]S 以在 shebang 行中传递选项\n错误信息中可以看出，env的把perl -T -w整个一串当成程序名，肯定找不到了。\n那么使用env如何传参数呢？那就是使用-S选项，看hello_u.pl：\n1 2 #!/usr/bin/env -S USER=neochin perl -T -w print \u0026#34;hello \u0026#34; . $ENV{\u0026#39;USER\u0026#39;} . \u0026#34;\\n\u0026#34;; 脚本需要环境变量USER(单纯想展示一下使用env写法还可以临时设置环境变量的优势功能)，我们通过env的参数指定为neochin。-S是split分割的意思，就是指明后面的字符串要拆开来解析。运行效果：\n[leo@leo-m shebang]$ chmod +x hello_u.pl [leo@leo-m shebang]$ ./hello_u.pl hello neochin\n灵活的注释 在日常开发过程中，并非所有的注释都是只是给程序员看的。\n比如在python2时代，我们通常使用单独一行注释# -*- coding: utf-8 -*-，指定python脚本的默认编码为utf-8。\n[leo@leo-m tmp]$ cat p.py print(\u0026#34;中文\u0026#34;) [leo@leo-m tmp]$ python2 p.py File \u0026#34;p.py\u0026#34;, line 1 SyntaxError: Non-ASCII character \u0026#39;\\xe4\u0026#39; in file p.py on line 1, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details [leo@leo-m tmp]$ [leo@leo-m tmp]$ [leo@leo-m tmp]$ cat p1.py # -*- coding: utf-8 -*- print(\u0026#34;中文\u0026#34;) [leo@leo-m tmp]$ python2 p1.py 中文\n又比如在团队协作时，通常需要输出API文档。为了减少单独编写及维护成本，我门通常使用第三方文档工具swagger，doxygen等，通过扫描代码、注释来完成文档的自动化生成。\n同时，注释还很好玩。用一个源码文件，支持不同语言运行，请看Polyglot。起飞吧，少年，秀儿就是你！\n参考资料 打不开链接的，请科学上网。\nShebang(Unix) - Wikipedia Advanced Bash-Scripting Guide env: Run a command in a modified environment Polyglot(computing) - Wikipedia ","description":"脚本第一行#!被称为`shebang`，用于指定脚本文件的解析指令(interpreter directive)。","id":5,"section":"lang","tags":["bash","shell","shebang","hashbang"],"title":"脚本第一行的 #! 是什么","uri":"http://codebugs.pub/lang/common/shebang/"},{"content":" 还没有想写的 ","description":"关于\"写BUG\"博客、\"neochin\"个人的一些描述","id":12,"section":"","tags":null,"title":"关于","uri":"http://codebugs.pub/about/"}]